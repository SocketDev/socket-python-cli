"""Helper module for loading and processing .socket.facts.json files."""

import json
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List
from copy import deepcopy

logger = logging.getLogger(__name__)


def load_socket_facts(file_path: str = ".socket.facts.json") -> Optional[Dict[str, Any]]:
    """
    Load a .socket.facts.json file into a dictionary.
    
    The .socket.facts.json file is generated by the Socket CLI reachability analysis
    and contains component dependency information, vulnerability data, and 
    reachability analysis results.
    
    Args:
        file_path: Path to the .socket.facts.json file. Defaults to ".socket.facts.json"
                  in the current directory.
    
    Returns:
        Dict containing the parsed JSON data with keys like:
        - components: List of dependency components with vulnerabilities and reachability info
        - tier1ReachabilityScanId: The scan ID for this reachability analysis
        
        Returns None if the file doesn't exist or cannot be parsed.
    
    Example structure:
        {
            "components": [
                {
                    "id": "12345",
                    "type": "npm",
                    "name": "package-name",
                    "version": "1.0.0",
                    "namespace": "@scope",
                    "direct": false,
                    "dev": true,
                    "vulnerabilities": [...],
                    "reachability": [...],
                    ...
                }
            ],
            "tier1ReachabilityScanId": "scan-id-here"
        }
    """
    facts_path = Path(file_path)
    
    if not facts_path.exists():
        logger.warning(f"Socket facts file not found: {file_path}")
        return None
    
    try:
        with facts_path.open('r', encoding='utf-8') as f:
            data = json.load(f)
        
        logger.debug(f"Successfully loaded socket facts from {file_path}")
        
        # Validate expected structure
        if not isinstance(data, dict):
            logger.warning(f"Socket facts file has unexpected format: expected dict, got {type(data)}")
            return None
        
        if 'components' not in data:
            logger.warning(f"Socket facts file missing 'components' key")
        
        return data
    
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON from {file_path}: {e}")
        return None
    except IOError as e:
        logger.error(f"Failed to read {file_path}: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error loading socket facts from {file_path}: {e}")
        return None


def get_components_with_vulnerabilities(facts_data: Dict[str, Any]) -> list:
    """
    Extract components that have vulnerabilities from socket facts data.
    
    Note: The .socket.facts.json file contains 'vulnerabilities' and 'reachability'
    data separately. This function returns components that have vulnerabilities defined.
    
    Args:
        facts_data: Dictionary loaded from .socket.facts.json
    
    Returns:
        List of component dictionaries that have vulnerabilities
    """
    if not facts_data or 'components' not in facts_data:
        return []
    
    components = facts_data.get('components', [])
    components_with_vulns = [
        comp for comp in components 
        if comp.get('vulnerabilities') and len(comp.get('vulnerabilities', [])) > 0
    ]
    
    return components_with_vulns


def get_scan_id(facts_data: Dict[str, Any]) -> Optional[str]:
    """
    Extract the tier1ReachabilityScanId from socket facts data.
    
    Args:
        facts_data: Dictionary loaded from .socket.facts.json
    
    Returns:
        The scan ID string if present, None otherwise
    """
    if not facts_data:
        return None
    
    scan_id = facts_data.get('tier1ReachabilityScanId')
    return scan_id.strip() if scan_id else None


def _make_purl(component: Dict[str, Any]) -> str:
    """Construct a package URL (purl) from a component entry."""
    pkg_type = component.get('type', '')
    namespace = component.get('namespace', '')
    name = component.get('name') or component.get('id', '')
    version = component.get('version', '')
    
    if not name:
        return ''
    
    if namespace:
        # Percent-encode @ in namespace for purl spec compliance
        ns_encoded = namespace.replace('@', '%40')
        purl = f"pkg:{pkg_type}/{ns_encoded}/{name}"
    else:
        purl = f"pkg:{pkg_type}/{name}"
    
    if version:
        purl = f"{purl}@{version}"
    
    return purl


def _determine_reachability(vulnerability: Dict[str, Any], component: Dict[str, Any]) -> Dict[str, Any]:
    """
    Determine the reachability state for a vulnerability on a component.
    
    Args:
        vulnerability: Vulnerability dict from component's vulnerabilities array
        component: Component dict containing reachability data
    
    Returns:
        Dict with keys:
        - type: 'reachable', 'unreachable', 'unknown', 'error', or 'not_applicable'
        - undeterminableReachability: bool
        - trace: list of formatted trace strings
    """
    result = {
        'type': 'unknown',
        'undeterminableReachability': False,
        'trace': []
    }
    
    vuln_id = vulnerability.get('ghsaId') or vulnerability.get('cveId')
    if not vuln_id:
        return result
    
    # Check for undeterminable reachability in the vulnerability data
    reach_data = vulnerability.get('reachabilityData') or {}
    if reach_data.get('undeterminableReachability'):
        result['undeterminableReachability'] = True
        result['type'] = 'unknown'
    
    # Find matching reachability entry in component
    reachability_list = component.get('reachability', [])
    matched_reach = None
    
    for reach_entry in reachability_list:
        if reach_entry.get('ghsa_id') == vuln_id:
            matched_reach = reach_entry
            break
    
    if not matched_reach:
        # No reachability data found for this vulnerability
        if result['undeterminableReachability']:
            return result
        # Check if this vulnerability applies to this component version
        if 'reachabilityData' in vulnerability:
            # Has reachability data structure but no match - might not apply
            result['type'] = 'not_applicable'
        return result
    
    # Process reachability matches
    reach_items = matched_reach.get('reachability', [])
    if not reach_items:
        return result
    
    # Take the first reachability entry (usually most relevant)
    reach_info = reach_items[0]
    reach_type = reach_info.get('type', 'unknown')
    result['type'] = reach_type
    
    # Build trace for reachable vulnerabilities
    if reach_type == 'reachable':
        matches = reach_info.get('matches', [])
        for match_group in matches:
            if not match_group:
                continue
            
            for i, frame in enumerate(match_group):
                pkg = frame.get('package', '')
                src_loc = frame.get('sourceLocation', {})
                filename = src_loc.get('filename', '')
                start = src_loc.get('start', {})
                line = start.get('line')
                col = start.get('column')
                end = src_loc.get('end', {})
                end_line = end.get('line')
                end_col = end.get('column')
                
                if i == 0:
                    # First frame - use filename as primary
                    if filename:
                        loc = filename
                        if line is not None:
                            if end_line is not None and end_line != line:
                                loc = f"{filename} {line}:{col if col else ''}-{end_line}:{end_col if end_col else ''}"
                            else:
                                loc = f"{filename} {line}:{col if col else ''}"
                        result['trace'].append(loc)
                else:
                    # Subsequent frames - show package/module reference
                    if pkg or filename:
                        entry = pkg if pkg else filename
                        if line is not None:
                            entry = f"  -> {entry} {line}:{col if col else ''}"
                        else:
                            entry = f"  -> {entry}"
                        result['trace'].append(entry)
        
        # Add final line showing the vulnerable component
        comp_name = component.get('name') or component.get('id')
        comp_ver = component.get('version')
        if comp_name:
            final_line = f"  -> {comp_name}@{comp_ver}" if comp_ver else f"  -> {comp_name}"
            result['trace'].append(final_line)
    
    return result


def convert_to_alerts(components: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Convert components with vulnerabilities into components with alerts.
    
    This function processes the raw .socket.facts.json format (with 'vulnerabilities' 
    and 'reachability' arrays) and converts them into an 'alerts' format suitable 
    for formatters and notifications.
    
    Args:
        components: List of component dicts from .socket.facts.json
    
    Returns:
        List of component dicts with 'alerts' field added (original components unchanged)
    """
    components_with_alerts = []
    
    for comp in components:
        vulns = comp.get('vulnerabilities', [])
        if not vulns:
            continue
        
        alerts = []
        for vuln in vulns:
            vuln_id = vuln.get('ghsaId') or vuln.get('cveId') or 'Unknown'
            
            # Extract severity
            sev_val = vuln.get('severity', '')
            severity = 'unknown'
            
            # Handle both numeric and string severities
            try:
                if isinstance(sev_val, (int, float)):
                    score = float(sev_val)
                    if score >= 9.0:
                        severity = 'critical'
                    elif score >= 7.0:
                        severity = 'high'
                    elif score >= 4.0:
                        severity = 'medium'
                    else:
                        severity = 'low'
                elif isinstance(sev_val, str):
                    # Try to parse as number first
                    if sev_val.replace('.', '', 1).isdigit():
                        score = float(sev_val)
                        if score >= 9.0:
                            severity = 'critical'
                        elif score >= 7.0:
                            severity = 'high'
                        elif score >= 4.0:
                            severity = 'medium'
                        else:
                            severity = 'low'
                    else:
                        # Use as-is if it's a string severity
                        severity = sev_val.lower()
            except (ValueError, TypeError):
                severity = 'unknown'
            
            # Determine reachability
            reach_info = _determine_reachability(vuln, comp)
            
            # Skip vulnerabilities that don't apply to this component version
            if reach_info.get('type') == 'not_applicable':
                continue
            
            # Build alert
            purl = _make_purl(comp)
            trace_str = '\n'.join(reach_info.get('trace', []))
            reach_type = reach_info.get('type', 'unknown')
            
            # Map reachability to severity (reachable = critical, unknown/error = high, unreachable = low)
            final_severity = severity
            if reach_type == 'reachable':
                final_severity = 'critical'
            elif reach_type in ('unknown', 'error') or reach_info.get('undeterminableReachability'):
                final_severity = 'high'
            elif reach_type == 'unreachable':
                final_severity = 'low'
            
            alert = {
                'title': vuln_id,
                'severity': final_severity,
                'type': 'vulnerability',
                'category': 'vulnerability',
                'props': {
                    'cveId': vuln.get('cveId'),
                    'ghsaId': vuln.get('ghsaId'),
                    'range': vuln.get('range'),
                    'purl': purl,
                    'reachability': reach_type,
                    'undeterminableReachability': reach_info.get('undeterminableReachability', False),
                    'trace': trace_str,
                    'severity': final_severity,
                    'original_severity': severity,
                }
            }
            alerts.append(alert)
        
        if alerts:
            # Create a copy with alerts added
            comp_with_alerts = deepcopy(comp)
            comp_with_alerts['alerts'] = alerts
            components_with_alerts.append(comp_with_alerts)
    
    return components_with_alerts


def get_component_count(facts_data: Dict[str, Any]) -> Dict[str, int]:
    """
    Get statistics about components in the socket facts data.
    
    Args:
        facts_data: Dictionary loaded from .socket.facts.json
    
    Returns:
        Dictionary with counts:
        - total: Total number of components
        - with_vulnerabilities: Components with vulnerabilities
        - direct: Direct dependencies
        - dev: Development dependencies
    """
    if not facts_data or 'components' not in facts_data:
        return {'total': 0, 'with_vulnerabilities': 0, 'direct': 0, 'dev': 0}
    
    components = facts_data.get('components', [])
    
    return {
        'total': len(components),
        'with_vulnerabilities': len([c for c in components if c.get('vulnerabilities')]),
        'direct': len([c for c in components if c.get('direct')]),
        'dev': len([c for c in components if c.get('dev')])
    }
